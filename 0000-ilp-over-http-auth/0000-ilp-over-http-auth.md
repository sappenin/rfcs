---
title: ILP-over-HTTP Authentication Profiles
draft: 1
---

# ILP-over-HTTP Auth Profiles
This RFC defines two baseline Authentication Profiles for 
[ILP-over-HTTP](https://github.com/interledger/rfcs/blob/master/0035-ilp-over-http/0035-ilp-over-http.md) that 
Interledger Nodes SHOULD implement.

## Motivation
When authenticating requests between Interledger nodes, it is important to find a careful balance between usability 
and security, while at the same time maintaining high-performance. 

This document defines several Authentication profiles for Interledger Nodes operating ILP-over-HTTP links in order to 
find this balance. This document also describes and clarifies some token-security best practices for Interledger Nodes.

## Overview
This RFC defines the following profiles, each of which allows two ILP nodes to authenticate the other party in an 
ILP-over-HTTP peering relationship. 

* `SIMPLE`: Allows two ILP nodes to utilize a previously agreed-upon shared-secret as a Bearer token in all ILP-over-HTTP 
requests. Peers SHOULD consider this token to be opaque and SHOULD NOT derive any special meaning from the token. 

* `JWT_HS_256`: Allows two ILP nodes to utilize a previously agreed-upon shared-secret in order to _derive_ a Bearer token 
that conforms to the JSON Web Token (JWT) specification. JWTs generated by this scheme can then be used as a Bearer 
in all ILP-over-HTTP requests.

Per the ILP-over-HTTP specification, "Peers MAY use any standard HTTP authentication mechanism to authenticate 
incoming requests." This RFC narrows that definition to clarify that that Peers SHOULD support both of the authentication 
profiles defined in this RFC, and MUST support `JWT_HS_256`. 

## SIMPLE Authentication Profile
This profile allows two ILP nodes to utilize a previously agreed-upon shared-secret that contains at least 32 bytes 
(256 bits) of randomly generated data, and is encoded using Base64. For example: `HEiMCp0FoAC903QHueY89gAWJHo/izaBnJU8/58rlSI=`.

### Example Usage
In this profile, the shared secret is passed as an `Authorization` header in each HTTP request, using the 
[Bearer token](https://tools.ietf.org/html/rfc6750) scheme, like this:
`Authorization: Bearer HEiMCp0FoAC903QHueY89gAWJHo/izaBnJU8/58rlSI=`. 

Because tokens in this profile do not inherently contain any information about the identity of the authentication 
request, callers using this profile MUST add an additional HTTP request header named `Auth-Principal` to each request. 
This allows for the identity of the authentication to be separated from authentication token itself. This is important
 so that implementations do not have to create data-store indexes using secure data, which might involve extra computational
 overhead. Depending on the implementation, the value of this header might represent an `ILP Account Id` or an `ILP Peer Id`.

Implementations MAY support this profile, but SHOULD consider it for development purposes only.
 
### Trade-off Summary
* **Pros**
  * The simplest, most usable Authentication profile -- just a shared-secret with _at least_ 32 bytes and an identity header.
  * Very little processing time to verify a token (just a simple value comparison; for more security an HMAC-SHA256 
    computation).

* **Cons**
  * The shared-secret is transmitted "on the wire" for every request, increasing the chances that it might be intercepted 
    by a compromised TLS session (e.g., a [MITM attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)); 
    a TLS termination endpoint (e.g., a Load Balancer); or logged by an internal system during transit.
  * The shared-secret itself never expires, so if an implementation neglects to rotate the secret with its peer, this 
    token will likely be very long-lived. This increases the chance of compromise by an attacker, and means compromised 
    usage of this type of token could go undetected for very longer periods of time.
  * Requires out-of-band communication for both peers to agree upon the shared secret.

## JWT_HS_256 Authentication
This profile allows two ILP nodes to utilize a previously agreed-upon shared-secret, but then derive an
[RFC-7519](https://tools.ietf.org/html/rfc7519) compliant JWT tokens in order to perform actual authentication.

### JWT Claims
In order to be considered a valid JWT for this profile, the signed JWT MUST contain a `sub` (subject) claim containing 
the identifier of the "principal" that the token authenticates. Depending on the implementation, the value of this claim 
will generally represent an `ILP Account Id`, but future implementations MAY make this represent an `ILP Peer Id` or 
some other value.

Optionally, a JWT token MAY also include an `exp` (expiry) claim that indicates a date/time after which the token should 
be considered invalid. Note that tokens without this claim never expire.

### Example Usage
In this profile, the Base64-encoded JWT is passed as an `Authorization` header in each HTTP request, using 
the [Bearer token](https://tools.ietf.org/html/rfc6750) scheme. 

One example of such a Bearer token:

`Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhbGljZSJ9._Jn0pkqrK1leE3WZJKn-g5hm5kGJxGdSHggtz5wO1w4`. 

Using the JWT specification, this token can be verified using the shared-secret previously agreed upon. For example, the 
above token contains a `sub` claim of `alice` and can be verified using a shared-secret value of 
`HEiMCp0FoAC903QHueY89gAWJHo` (Base64 encoded).

Another example of a Bearer token that contains an expiration date:

`Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhbGljZSIsImV4cCI6MTU1ODAzNTg2OH0.__9CiSGdn4Grhl48slun7Lp4q4xt0uq398omcipBU8M`. 

Using the JWT specification, this token can be verified using the shared-secret previously agreed upon. For example, the 
above token contains a `sub` claim of `alice` and an `exp` claim of `1558035868`, which means this token is no longer
valid after `May 16th, 2019 at 9:29:11 GMT`. This token can be verified using a shared-secret value 
of `HEiMCp0FoAC903QHueY89gAWJHo` (Base64 encoded).

### Trade-off Summary
* **Pros**
  * Same usability as the `SIMPLE` profile -- just a shared-secret with _at least_ 32 bytes and a `sub` claim.
  * Allows both identity and authentication claims to be contained in single Bearer token, which eliminates the need for 
    a second `Auth-Principal` header. This should simplify token validation and ease account-lookup (no need to create 
    an HMAC or encrypted data-store index).
  * Requires only enough processing to perform an HMAC-SHA256 signing operation, which is very fast.
  * Allows authentication tokens to be generally short-lived so that peers can narrow the potential window of 
    unauthorized usage in the event of token compromise.
  * The actual shared-secret is _never_ transmitted "on the wire" during any request. Instead, authentication tokens 
    are always _derived_ from the shared-secret, which eliminates the risk of an _actual_ shared-secret being intercepted 
    in transit.

* **Cons**
  * Total transmitted bytes for authentication are more than the `SIMPLE` scheme (about 41 bytes, or ~50% more). However, HTTP/2
    header compression should mitigate this differential.
  * The JWT authentication token never expires, so if an implementation neglects to rotate the secret with its peer, this 
    token will likely be very long-lived. This increases the chances of compromise by an attacker, and means compromised 
    usage of this type of token could go undetected for very longer periods of time.
  * Requires out-of-band communication for both peers to agree upon the shared secret.
  
## Best Practices

### Follow Standardized Security Recommendations
It is advisable to follow any all all applicable best practices when using a Bearer-token scheme for authentication. 
[Section 5.1 of RFC-6570](https://tools.ietf.org/html/rfc6750#section-5) contains a number of very good practices that 
should be considered on a per-deployment basis. 

### Use SIMPLE Profile for Development/Testing Only
The `SIMPLE` authentication profile provides only marginal benefits over the `JWT_HS_256` profile, and should be used for Development or
Test systems only. Prefer `JWT_HS_256` for production deployments.

### Use Reasonable Token Expirations
Tokens should have a reasonable lifetime validity so that they can be cached in-memory for fast authentication decisions,
but also limit the attack surface caused by a compromised token. In other words, don't use tokens that never expire. For 
example, consider generating tokens with a token lifetime that doesn't exceed 5 minutes.

### Secrets At Rest
In most ILP Connector implementations, secrets are stored on a per-account basis in some sort 
of data-store. Implementations SHOULD protect secret-values that can be used to generate authentication tokens from 
being captured by unauthorized parties by encrypting them prior to storage. This will help ensure that only the Connector 
runtime can generate tokens by decrypting any shared secrets.

One option is to encrypt any secrets at-rest using an Authenticated Encryption algorithm, such as AES-GCM-256. 
This [article](https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9) 
provides a nice overview using Java, along with various configuration options to consider.
  
### Secrets In Memory
Implementations SHOULD minimize the amount of time that an actual secret-value exists in-memory in unencrypted form. 
This includes narrowing the availability of secrets to only code that actually requires them; minimizing the time any 
secret might exist in memory; and zeroing out memory after a secret is no longer used, if possible. 
  
### High Security Deployments
For deployments requiring very high security, it is recommended to utilize a secret-store deployed outside of the Connector 
 runtime, such as [Vault](https://www.vaultproject.io/) or an 
 [HSM](https://safenet.gemalto.com/data-encryption/hardware-security-modules-hsms/) or both. This will provide an extra 
 layer of protection in case a Connector runtime is compromised, and will also make it significantly harder for an attacker
 to compromise actual shared-secret values (especially if employing an HSM).

# References
For more details on the algorithms and technologies referenced in this RFC, see the following:

* RFC-7518: [JSON Web Algorithms (JWA)](https://www.rfc-editor.org/rfc/rfc7518.html)
* RFC-7519: [JSON Web Token (JWT)](https://www.rfc-editor.org/rfc/rfc7519.html)

# Future Authentication Profiles
The [JSON Web Algorithms (JWA)](https://www.rfc-editor.org/rfc/rfc7518.html) RFC specifies a variety of alternative signature 
algorithms that could be used as future authentication profiles for ILP Connectors using ILP-over-HTTP. 

For example, alternative schemes based upon public/private key-pairs using RSA or Eliptic Curve algorithms provide interesting
benefits, and should align with the profiles defined in this RFC with minimal changes. One particular advantage
of using a public/private keys to derive Authentication tokens is that it eliminates the need for exchanging shared-secrets 
between two Peers. This type of system also better supports third-party token generation (e.g., for a delegated authentication
setup) which may prove valuable in future systems. 

The primary reason these schemes are not part of this RFC is that signature computation times are typically longer than 
for the HMAC-based schemes defined in this document.
